# M2D2 Documentation

## Outline
- [Installing](#installing)
- [Quick Start](#quick-start)
- [Rendering](#rendering)
  - [Loading](#loading)
  - [DOM objects](#dom-objects)
  - [Short Assign](#short-assign)
  - [Locating elements](#locating-elements)
  - [Linking elements](#linking-elements)
    - [Double references](#double-references)
    - [Resolving conflicts](#resolving-conflicts)
  - [CSS and styles](#css-and-styles)
  - Show / Hide elements
  - Events
    - onload
    - onready
  - Updating reference
    - linked references (inline)
    - onupdate
    - no selector = HTML Fragment
- Forms
  - Properties
  - Many selector
- Lists
  - Templates
  - Events in templates
  - Selected item
  - Sorting
- Extending
- Extensions
  - Alert
  - Lang
  - Storage
  - XHR
    - Upload
  - WS
- Improving Performance
  - Short Updates OFF
  - Proxy OFF
- Utils
- Using with Framework7

## Installing

Installation instructions for `node` or the web, are explained in the main [README page](../README.md#Install).

## Quick Start

If you have 5 minutes, check our [Quick Start Guide](quick.md).

## Rendering
### Loading

To initialize M2D2, you have mainly two options:

The first one, is to execute some code after the DOM is ready:
```js
m2d2.ready($ => { ... });
```
The variable `$` can be anything you choose (any variable name allowed by Javascript). 
Throughout all the documentation, examples and tutorials we use `$` for  simplicity
(please don't get confused with JQuery `$`).

The other option is used when you want to have access to M2D2 before the DOM is ready
or after you know for a fact that it is ready (for example, if you use your scripts at the end of
your HTML document, you want to [implement an extension](#extending), 
when [using together with another framework/library](#using-with-framework7), etc.):

```js
$ = m2d2.load();
```

### DOM objects

The most basic functionality is to access to DOM elements easily:

```js
const user = $("#user");
```

In this example `user` is an extended DOM object. In addition to all the methods and properties
that a DOM element (HTMLElement or Node) possess, we are adding other methods and properties 
which are convenient to simplify your code, for example:

* text : Set or Get text in Nodes
```js
user.text = 'Hello World';

console.log(user.text);
```

* html : Set or Get HTML in Nodes (useful if HTML comes from the server, not recommended otherwise)
```js
const fromServer = `<div class='blue'>User</div>`;
user.html = fromServer;

console.log(user.html);
```

* find(selector) : find the child which matches the CSS selector
* findAll(selector) : find all children who match the CSS selector
* sibling(selector) : find the sibling which matches the CSS selector
```js
user.find(".delete").click();
user.findAll("li").forEach(li => { li.delete() });
user.sibling(".message");
```

* index() : Get the index (position) of child within its parent node
```js
movies.find(".favorite").index()
```

* parent() : Get parent node
* next() : Get next sibling element
* prev() : Get previous sibling element
```js
movies.parent()
movies.find(".favorite").next()
```
More about `index`, `next` and `prev` in [lists](#lists)

Other additional methods/properties added to Nodes (explained later):

 * css : [Specify class name(s)](#css-and-styles)
 * getData() : [get data object of a form](#forms)
 * inView : [if element is in view](#show--hide-elements)
 * show : [show/hide element](#show--hide-elements)

Additional events:

 * onload(event => { ... }) : [element was processed](#onload)
 * onready(event => { ... }) : [element is ready](#onready)
 * onshow(event => { ... }) : [element is now shown](#show--hide-elements)
 * onupdate(event => { ... }) : [element was updated](#onupdate)

### Short Assign

To simplify your code, M2D2 will guess which properties you are trying to set.
For example, you can place your data in this way:

```js
const user = $("#user", {
    name : {
        text : "Yoda"
    },
    age : {
        text : 900
    }
    email : {
        text : "yoda@starwars.com"
    }
});
```

But it is easier this way:

```js
const user = $("#user", {
    name : "Yoda",
    age : 900,
    email : "yoda@starwars.com"
});
```

Depending on the element in which you are trying to set this data, M2D2 will decide 
which property to set it to. If, for example, `age` is an `span` element, it will set the `text` property,
but if it is an `input` element, it will set it as `value`:

```html
<span class="age">900</span>
<input type="number" name="age" value="900" />
```

This is specially useful if your data comes from a server (which usually does), for example:

```js
$.get("/user/yoda", response => {
  if(response.data) {
    const user = $("#user", response.data);
  }
});
```

In which, `response.data` is an object (from JSON) which matches your structure (or vice-versa).

> NOTE: `$.get` is from the [XHR extension](#xhr)

In order to achieve this functionality, M2D2 uses a `Proxy` object, which may not be supported 
in old browsers. To turn this feature OFF, you can set: `m2d2.short = false` at the beginning 
of your code.

More about how to access the elements' data when using `short assignment` 
in [Linking Elements](#linking-elements)

### Locating Elements

M2D2 will try its best to guess which node or property you are trying to assign, for example:

```html
<div id="user" title="User Info">
  <span class="name"></span>
  <form>
    <label><input type="text" name="age" /></label>
  </form>
</div>
```

```js
const user = $("#user", {
    title : "User : Karen McLaren",  // <--- user.title property
    name  : "Karen McLaren",         // <--- span.name element
    age   : 30,                      // <--- input[name=age] element
    label : "Age: ",                 // <--- label element
});
```

M2D2 will first look for `<tag>`, `#id`, `[names]` and `.classes` in that order.

### Linking Elements

One of the most interesting features in M2D2 is that you don't need to represent
your data exactly in the same way you have your HTML structure. For example:

```html
<div id="user">
  <form>
    <div class="wrapper">
      <fieldset>
        <div class="name">
          <label>First Name:</label>
          <input type="text" name="first" />
          <label>Middle Name:</label>
          <input type="text" name="middle" />
          <label>Last Name:</label>
          <input type="text" name="last" />
        </div>
      </fieldset>
    </div>
  </form>
</div>
```

In order to set the "Last Name", you don't need to do: `user.form.wrapper.fieldset.name.last` 
(which would be painful), you can skip to the important parts:

```js
const user = $("#user", {
  first  : "Barney",
  middle : "Waitforit",
  last   : "Stinson"
});
```
And later, you can access or modify it easily:

```js
user.middle = "Legendary"
console.log(user.middle.value)
```

> NOTE: The [short assignment](#short-assign) can only be used when setting a value into
an element or property and not when accessing it.

What happens, is that M2D2 creates links in the `user` object that points to the child elements
of our choice (so we don't have to specify each step in the DOM tree). 

One advantage of doing so, is that if we redesign our HTML completely, as long as we
keep the classes, names or ids in place, you won't need to change your Javascript. For example,
the above `user` example, will work as well in this HTML (no matter the order of the elements):

```html
<section id="user">
  <div class="last"></div>
  <div class="first"></div>
  <div class="middle"></div>
</section>
```

Keeping the previous example in mind, `user` is an HTMLElement (or DOM Node), so you can set
its `title` property as usual: 

```js
user.title = 'Title'
// and read it in the same way: 
console.log(user.title)
```

But for child elements:

```js
user.first = "Barry"
console.log(user.first)       // This will print the HTMLElement object
console.log(user.first.text)  // This will print the property "text"
```

You can not use [short assignment](#short-assign) in root elements, the following **IS NOT CORRECT**:

```js
user = "Not Correct"  // Trying to replace variable `user`
```

Fortunately we set `user` as `const`, so that will never be allowed. The only way it will work is
if we specify the property:

```js
user.text = "Correct"
```

#### Double references

You can always (when needed) create different M2D2 objects using the same elements, for example:

```html
<div id="user">
  <div class="name"></div>
  <div class="email"></div>
</div>
```
```js
const basic = $("#user", {
  name : "jannete"
});
const advanced = $("#user", {
  email : "jan@example.com"
}
```
In this case, `basic` and `advanced` are just aliases:

```js
console.log(basic.email.text);    // prints "jan@example.com"
console.log(advanced.name.text);  // prints "jannete"
``` 

Possible applications for these "double references" are:

* Parts of the data comes from different data sources
* Simplify code by referring to different parts of the layout (shallow vs deep)
* Keep a logical reference to an element which may change over time (like: `user.main` 
in the case of having several users)

#### Resolving conflicts

There are times in which you may want to use a class or id of an existing property:

```html
<div id="user" title="User Profile">
  <h1 class="title">User :</h1>
</div>
```

```js
const user = $("#user", {
  title: "New Title"
});
```

As `user.title` is an existing property (which can not be replaced), M2D2 will create a link to 
the `h1` element as: `user.$title` (and report it in the console logs). 

In order to prevent conflicts, it is better to replace the class name or if you can't replace it
(due to style declarations), add another class to access it, for example:

```html
<div id="user" title="User Profile">
  <h1 class="title user_title">User :</h1>
</div>
```
```js
const user = $("#user", {
  user_title: "New Title"
});
```

Other way can be to handle `h1` element separately from `user`:

```js
const user_title = $("#user .title");
```

### CSS and styles

To make things easier to manage CSS class names, all M2D2 elements
have the `css` property, which you can set in this way:

```js
const user = $("#user", {
    css : "myclass",          // `<div class='myclass' ...
    css : ["full", "blue"],   // `<div class='full blue' ...
});
// Or:
user.css = "myclass";
user.css = ["full", "blue"];
```

In both of the cases, `css` will replace any existing classes with the ones specified.
If you want to add or remove classes, you need to set an object with `true` (add), 
or `false` (remove) as values:

```js
const user = $("#user", {
    css : {
        full : true,  // will add "full" to existing classes
        link : false  // will remove "link" class if exists
    }, 
});
// Or:
user.css = { full : true, link : false }
```

When you read the `css` property, it will return the `classList` Node property:

```js
user.css.contains("link");
user.css.add("blue");
user.css.remove("red");
user.css.toggle("active");
user.css.length;
user.css.forEach(cls => { ... })
```

You can also set the style you want directly:

```js
const user = $("#user", {
  style : {
     color : "green",  // or any HTML supported value
     backgroundColor : "#3338",  // background-color becomes backgroundColor in Javascript
     display : "inline"
  }
});
// Or:
user.style.backgroundColor = "#3338";
```

### Show / Hide elements



### Events
  #### onload
  #### onready
### Updating reference
  #### linked references
  #### onupdate
  #### no selector = HTML Fragment
## Forms
### Properties
### Many selector
## Lists
### Templates
### Events in templates
### Selected item
### Sorting
## Extending
## Extensions
  ### Alert
  ### Lang
  ### Storage
  ### XHR
    ### Upload
  ### WS
## Improving Performance
### Short Updates OFF
### Proxy OFF
## Utils
## Using with Framework7
